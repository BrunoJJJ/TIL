### 자료구조란?
데이터가 어떻게 구조화 되어 있는지, 데이터 접근 검색 추가 삭제를 위한 시간 복잡도가 달라질 수 있다.

- - - 

## Array, LinkedList, Stack, Queue

linkedlist 는 각 list의 원소가 자신의 앞과 뒤 원소에 대한 참조를 저장하고 있음.

이러한 구조적 특징은 절대 경로 index를 통해 접근 불가.

앞원소 or 뒤 원소부터 타고 들어가야함. but 원소의 추가와 삭제가 간편함.

크기가 가변적인 배열이 필요하다면 ArrayList

LinkedList의 삭제, 추가 시간 복잡도는 O(N)이지만 Array나 ArrayList보다 빠름

데이터의 삭제 추가가 많을 때 -> LinkedList(자료구조의 List는 연결리스트를 의미)

데이터의 접근이 많을 때 -> Array, ArrayList

Array, ArrayList는 인덱스가 있지만 LinkedList는 없다

스택은 push, pop 시간복잡도 O(1)

search O(n)

stack queue / array로 구현한 queue의 한계점 보안 -> 원형 큐

사실상 리스트로 다 가능 mutable list 이용 linked list

- - -

## Map, Set, Tree, Heap, Graph

heap

완전이진트리 형태(최솟값, 최댓값을 빠르게 찾아내기 위함)

우선순위 큐를 위해 만들어짐 => 데이터들이 우선순위를 가지고 우선순위 높은 데이터가 큐에서 먼저 빠져 나감.

중복된 값을 허용. (이진 탐색 트리는 허용 x - 당연한..?)

힙 종류 : 최대 힙, 최소 힙

우선 순위 큐는 배열, 연결리스트, 힙으로 구현 가능하지만 힙이 가장 효율적

최솟값이나 최댓값을 찾기 위해 배열을 사용하면 Ο(n)만큼 시간이 걸린다.
하지만 힙을 사용하면 O(logn)만큼 소요되므로, 배열을 사용할 때보다 빠르게 최솟값과 최댓값을 구할 수 있다.

우선순위 큐와 같이 최댓값 또는 최솟값을 빠르게 찾아야하는 알고리즘 등에 활용된다.

힙에서 중요한 것은 인덱스, 인덱스를 통해 부모, 자식 간의 비교를 해야하기 때문에
즉, 첫번째 0인 인덱스는 사용하지 않고 1부터 시작해야함. 루트 노드가.
힙은 queue 개념이기 때문에 루트가 나가고 마지막 노드에 추가된다는 개념 이해.

완전 이진 트리 - 마지막 레벨 제외하고 노드들이 모두 채워지고
마지막 레벨은 왼쪽부터 채워져 있어야함.

전 이진 트리 - 모든 노드가 0개 or 2개의 자식 노드를 갖는 트리

포화 이진 트리 - 완전이진트리 + 전이진트리
노드 개수 2^(k-1) k : 트리의 높이

이진 탐색 트리 -> 왼쪽 자식 노드 < 부모노드 < 오른쪽 자식노드
이진탐색과 연결리스트를 결합한 자료구조 일종, 이진 탐색의 효율적인 탐색 능력 + 빈번한 자료의 입력과 삭제 가능하도록..
힙, 이진 탐색 트리 - 모두 완전 이진 트리
힙은 최대/최소 검색 ///// 이진 탐색 트리는 탐색을 위한 구조

트리 구현(그래프의 한 종류, 그래프의 구현 방법으로 가능 -> 인접 리스트, 인접 배열)
인접 배열 이용

1차원 배열에 자신의 부모 노드만 저장하는 방법
트리는 부모 노드를 0개 또는 1개를 가지기 때문
부모 노드를 0개: 루트 노드
이진 트리의 경우, 2차원 배열에 자식 노드를 저장하는 방법
이진 트리는 각 노드가 최대 두 개의 자식을 갖는 트리이기 때문
Ex) A[i][0]: 왼쪽 자식 노드, A[i][1]: 오른쪽 자식 노드
인접 리스트 이용

가중치가 없는 트리의 경우
ArrayList< ArrayList > list = new ArrayList<>();
가중치가 있는 트리의 경우

1. class Node { int num, dist; // 노드 번호, 거리 } 정의
2. ArrayList[] list = new ArrayList[정점의 수 + 1];
3. 
https://gmlwjd9405.github.io/2018/08/12/data-structure-tree.html

그래프 : 연결되어 있는 원소 간의 관계를 나타내는 자료구조
